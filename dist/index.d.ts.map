{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAM/B,MAAM,WAAW,eAAe;IAC5B,KAAK,EAAE,OAAO,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;CACpB;AAuHD,wBAAgB,aAAa,CACzB,gBAAgB,EAAE,OAAO,KAAK,CAAC,SAAS,EACxC,gBAAgB,CAAC,EAAE,OAAO,KAAK,CAAC,SAAS,EACzC,cAAc,CAAC,EAAE,OAAO,KAAK,CAAC,SAAS,GACxC,OAAO,KAAK,CAAC,SAAS,CAkExB;AAED,yBAAiB,aAAa,CAAC;IAC3B,SAAgB,UAAU,CAAC,cAAc,KAAA,QAWxC;IACD,SAAgB,GAAG,iBAElB;IACD,SAAgB,gBAAgB,QAE/B;IACD,SAAgB,UAAU,WAEzB;IACD,SAAgB,UAAU,WAEzB;IACD,SAAgB,kBAAkB,CAAC,EAAE,KAAA,QAEpC;IACD,SAAgB,wBAAwB,CAAC,EAAE,KAAA,QAE1C;IACD,SAAgB,QAAQ,CAAC,KAAK,KAAA,QAa7B;IACD,SAAgB,gBAAgB,CAAC,EAAE,KAAA,QAElC;CACJ;AAED,eAAe,aAAa,CAAC","file":"index.d.ts","sourcesContent":["import * as React from 'react';\nimport axios from 'axios';\nimport state_definition from './state';\n\n\n\nexport interface WithConfigState {\n    error: boolean;\n    loading: boolean;\n}\n\ntype Status = \"not_initialized\" | \"fetching\" | \"completed\" | \"failed\";\n\nlet stores = [];\n\nlet base_uri = window.location.protocol + '//' + window.location.host;\nlet config_asset_uri = '/config.json';\n\nlet default_cfg: object = {};\nlet fetched_cfg: object = {};\nlet combined_cfg = {};\n\nlet debug_cb = null;\n\nlet fetched_cb = null;\nlet fetching_error_cb = null;\nlet fetching_error = null;\n\nlet fetching_status: Status = 'not_initialized';\nlet get_config_listeners = [];\nlet component_listeners = [];\n\nfunction initiateFetch(): Promise<any> {\n    fetching_status = 'fetching';\n    if (debug_cb) {\n        debug_cb(\"Fetching: \" + base_uri + config_asset_uri);\n    }\n\n    return axios({\n        url: base_uri + config_asset_uri,\n        method: 'GET'\n    }).then((res) => {\n        fetched_cfg = res.data;\n        if (debug_cb) {\n            debug_cb(\"Fetch completed \" + JSON.stringify(fetched_cfg));\n        }\n        combined_cfg = Object.assign({}, default_cfg, fetched_cfg);\n        fetching_status = 'completed';\n        stores.forEach((store) => {\n            store.actions.set(combined_cfg);\n        });\n        if (fetched_cb !== null) {\n            fetched_cb(combined_cfg);\n        }\n        get_config_listeners.forEach((listener) => {\n            listener();\n        });\n        setTimeout(() => {\n            //Timeout here to force the component listeners to the end of the execution chain,\n            //after the callbacks have all been executed.\n            component_listeners.forEach((listener) => {\n                listener();\n            });\n            if (debug_cb) {\n                debug_cb(\"Component listeners called.\");\n            }\n        }, 10);\n    }).catch((err) => {\n        if (debug_cb) {\n            debug_cb(\"Fetching failed: \" + err.message);\n        }\n        fetching_status = 'failed';\n        err.network_error = true;\n        fetching_error = err;\n        if (fetching_error_cb !== null) {\n            fetching_error_cb(err);\n            return;\n        }\n        if (\n            get_config_listeners.length === 0 &&\n            fetching_error_cb === null\n        ) {\n            console.error('withConfig: ERROR WHEN FETCHING CONFIG:');\n            console.error(err);\n        }\n        get_config_listeners.forEach((listener) => {\n            listener();\n        });\n        component_listeners.forEach((listener) => {\n            listener();\n        });\n        throw err;\n    });\n}\n\nfunction getCfg(): Promise<any> {\n    return new Promise((resolve, reject) => {\n        if (fetching_status === 'completed') {\n            resolve(combined_cfg);\n            return;\n        }\n        if (fetching_status === 'failed') {\n            reject(fetching_error);\n            return;\n        }\n        get_config_listeners.push(() => {\n            if (fetching_status === 'completed') {\n                resolve(combined_cfg);\n                return;\n            }\n            reject(fetching_error);\n            return;\n        });\n        if (fetching_status === 'not_initialized') {\n            resolve(initiateFetch());\n        }\n    });\n}\n\nfunction getCurrentCfg(): any {\n    if (fetching_status !== \"completed\") {\n        console.warn(`withConfig: getConfig was run before config finished fetching.\n        withConfig.fetch() returns a promise which resolves when fetch completes, you might want to use it instead.`);\n    }\n    return combined_cfg;\n}\n\n\nexport function WithConfigHOC(\n    WrappedComponent: typeof React.Component,\n    SpinnerComponent?: typeof React.Component,\n    ErrorComponent?: typeof React.Component\n): typeof React.Component {\n    class WithConfig extends React.Component<any, WithConfigState> {\n        constructor(props) {\n            super(props);\n\n            this.state = { error: false, loading: true };\n        }\n\n        componentListener() {\n            if (fetching_status === 'failed') {\n                this.setState({ error: true });\n            }\n            this.setState({ loading: false });\n        }\n\n        componentDidMount() {\n            component_listeners.push(() => {\n                this.componentListener();\n            });\n            if (fetching_status === 'completed') {\n                this.setState({ loading: false });\n                return;\n            }\n            if (fetching_status === 'not_initialized') {\n                initiateFetch();\n            }\n        }\n\n        componentWillUnmount() {\n            let listener_index = component_listeners.indexOf(\n                this.componentListener\n            );\n            component_listeners.splice(listener_index, 1);\n        }\n\n        render() {\n            if (this.state.error) {\n                if (ErrorComponent) {\n                    return <ErrorComponent />;\n                }\n                return (\n                    <p\n                        style={{\n                            textAlign: 'center',\n                            marginTop: '20%'\n                        }}\n                    >\n                        Oops, something went wrong.\n                    </p>\n                );\n            }\n            let store_status = stores.every((store) => {\n                return store.getState().config_initialized === true;\n            });\n\n            if (this.state.loading || !store_status) {\n                if (SpinnerComponent) {\n                    return <SpinnerComponent {...this.props} />;\n                }\n                return null;\n            }\n            return <WrappedComponent config={combined_cfg} config_state={this.state} {...this.props} />;\n        }\n    }\n\n    return WithConfig;\n}\n\nexport namespace WithConfigHOC {\n    export function setDefault(default_config) {\n        if (Object.keys(default_cfg).length > 0) {\n            console.error('withConfig error: Cannot setDefault; Default config already set!');\n            return;\n        }\n        if (typeof default_config !== 'object') {\n            console.error('withConfig error: Arguemnt default_config is required to be an object.');\n            return;\n        }\n        default_cfg = default_config;\n        combined_cfg = Object.assign({}, default_cfg, fetched_cfg);\n    }\n    export function get() {\n        return getCfg();\n    }\n    export function getCurrentConfig() {\n        return getCurrentCfg();\n    }\n    export function getDefault() {\n        return default_cfg;\n    }\n    export function getFetched() {\n        return fetched_cfg;\n    }\n    export function setFetchedCallback(cb) {\n        fetched_cb = cb;\n    }\n    export function setFetchingErrorCallback(cb) {\n        fetching_error_cb = cb;\n    }\n    export function addStore(store) {\n        let i = stores.push(store.addState(\"config\", state_definition));\n        if (stores[i - 1].hasOwnProperty(\"addUpdateCallback\") === false) {\n            throw new Error(\"Missing prop 'addUpdateCallback' on addState return object. Ensure store version >=3.0.8.\");\n        }\n        stores[i - 1].addUpdateCallback(() => {\n            component_listeners.forEach((listener) => {\n                listener();\n            });\n        });\n        if (fetching_status === \"completed\") {\n            stores[i - 1].actions.set(combined_cfg);\n        }\n    }\n    export function setDebugCallback(cb) {\n        debug_cb = cb;\n    }\n}\n\nexport default WithConfigHOC;\n"],"sourceRoot":"/source/"}