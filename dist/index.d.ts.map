{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAM/B,MAAM,WAAW,kBAAkB;IAC/B,UAAU,EAAE,CAAC,GAAG,KAAA,KAAK,IAAI,CAAC;IAC1B,KAAK,EAAE,MAAM,GAAG,CAAC;IACjB,SAAS,EAAE,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;IAC9B,UAAU,EAAE,MAAM,GAAG,CAAC;IACtB,UAAU,EAAE,MAAM,GAAG,CAAC;IACtB,kBAAkB,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,KAAA,KAAK,GAAG,KAAK,IAAI,CAAC;IAC/C,wBAAwB,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,KAAA,KAAK,GAAG,KAAK,IAAI,CAAC;CACxD;AAED,MAAM,WAAW,eAAe;IAC5B,KAAK,EAAE,OAAO,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;CACpB;AA+FD,sCACI,gBAAgB,EAAE,OAAO,KAAK,CAAC,SAAS,EACxC,gBAAgB,CAAC,EAAE,OAAO,KAAK,CAAC,SAAS,EACzC,cAAc,CAAC,EAAE,OAAO,KAAK,CAAC,SAAS,GACxC,OAAO,KAAK,CAAC,SAAS,CA8DxB;AAED,yBAAiB,aAAa,CAAC;IAC3B,oBAA2B,cAAc,KAAA,QAqBxC;IACD,+BAEC;IACD,mCAEC;IACD,2BAEC;IACD,2BAEC;IACD,4BAAmC,EAAE,KAAA,QAEpC;IACD,kCAAyC,EAAE,KAAA,QAE1C;CACJ;AAED,eAAe,aAAa,CAAC","file":"index.d.ts","sourcesContent":["import * as React from 'react';\nimport axios from 'axios';\nimport withState from 'with-state';\nimport state_definition from './state';\n\n\nexport interface WithConfigFunction {\n    setDefault: (any) => void;\n    fetch: () => any;\n    getConfig: () => Promise<any>;\n    getDefault: () => any;\n    getFetched: () => any;\n    setFetchedCallback: (cb: (any) => any) => void;\n    setFetchingErrorCallback: (cb: (any) => any) => void;\n}\n\nexport interface WithConfigState {\n    error: boolean;\n    loading: boolean;\n}\n\nlet state = withState.addState(\"config\", state_definition);\nconsole.log(state);\n\nlet base_uri = window.location.protocol + '//' + window.location.host;\nlet config_asset_uri = '/config.json';\n\nlet default_cfg = null;\nlet fetched_cfg = null;\nlet combined_cfg = {};\n\nlet fetched_cb = null;\nlet fetching_error_cb = null;\nlet fetching_error = null;\n\nlet fetching_status = 'not_initialized';\nlet get_config_listeners = [];\nlet component_listeners = [];\n\nfunction initiateFetch(): Promise<any> {\n    fetching_status = 'fetching';\n\n    return axios({\n        url: base_uri + config_asset_uri,\n        method: 'GET'\n    })\n        .then((res) => {\n            fetched_cfg = res.data;\n            combined_cfg = Object.assign({}, default_cfg, fetched_cfg);\n            fetching_status = 'completed';\n            state.actions.set(combined_cfg);\n            if (fetched_cb !== null) {\n                fetched_cb(combined_cfg);\n            }\n            get_config_listeners.forEach((listener) => {\n                listener();\n            });\n            component_listeners.forEach((listener) => {\n                listener();\n            });\n        })\n        .catch((err) => {\n            fetching_status = 'failed';\n            err.network_error = true;\n            fetching_error = err;\n            if (fetching_error_cb !== null) {\n                fetching_error_cb(err);\n                return;\n            }\n            if (\n                get_config_listeners.length === 0 &&\n                fetching_error_cb === null\n            ) {\n                console.error('withConfig: ERROR WHEN FETCHING CONFIG:');\n                console.error(err);\n            }\n            get_config_listeners.forEach((listener) => {\n                listener();\n            });\n            component_listeners.forEach((listener) => {\n                listener();\n            });\n            throw err;\n        });\n}\n\nfunction getCfg(): Promise<any> {\n    return new Promise((resolve, reject) => {\n        if (fetching_status === 'completed') {\n            resolve(combined_cfg);\n            return;\n        }\n        if (fetching_status === 'failed') {\n            reject(fetching_error);\n            return;\n        }\n        get_config_listeners.push(() => {\n            if (fetching_status === 'completed') {\n                resolve(combined_cfg);\n                return;\n            }\n            reject(fetching_error);\n            return;\n        });\n        if (fetching_status === 'not_initialized') {\n            initiateFetch();\n        }\n    });\n}\n\n\n\n\n\nexport function WithConfigHOC (\n    WrappedComponent: typeof React.Component,\n    SpinnerComponent?: typeof React.Component,\n    ErrorComponent?: typeof React.Component\n): typeof React.Component {\n    class WithConfig extends React.Component<any, WithConfigState> {\n        constructor(props) {\n            super(props);\n\n            this.state = { error: false, loading: true };\n        }\n\n        componentListener() {\n            if (fetching_status === 'failed') {\n                this.setState({ error: true });\n            }\n            this.setState({ loading: false });\n        }\n\n        componentDidMount() {\n            component_listeners.push(() => {\n                this.componentListener();\n            });\n            if (fetching_status === 'completed') {\n                this.setState({ loading: false });\n                return;\n            }\n            if (fetching_status === 'not_initialized') {\n                initiateFetch();\n            }\n        }\n\n        componentWillUnmount() {\n            let listener_index = component_listeners.indexOf(\n                this.componentListener\n            );\n            component_listeners.splice(listener_index, 1);\n        }\n\n        render() {\n            if (this.state.error) {\n                if (ErrorComponent) {\n                    return <ErrorComponent />;\n                }\n                return (\n                    <p\n                        style={{\n                            textAlign: 'center',\n                            marginTop: '20%'\n                        }}\n                    >\n                        Oops, something went wrong.\n                    </p>\n                );\n            }\n            if (this.state.loading) {\n                if (SpinnerComponent) {\n                    return <SpinnerComponent {...this.props} />;\n                }\n                return null;\n            }\n            return <WrappedComponent config={combined_cfg} {...this.props} />;\n        }\n    }\n\n    return WithConfig;\n}\n\nexport namespace WithConfigHOC {\n    export function setDefault(default_config) {\n        if (default_cfg !== null) {\n            console.error(\n                'withConfig error: Cannot setDefault; Default config already set!'\n            );\n            return;\n        }\n        if (typeof default_config !== 'object') {\n            console.error(\n                'withConfig error: Arguemnt default_config is required to be an object.'\n            );\n            return;\n        }\n        if (fetching_status !== 'not_initialized') {\n            console.error(\n                'withConfig error: Cannot setDefault after a withConfig-wrapped component has been mounted.'\n            );\n            return;\n        }\n        default_cfg = default_config;\n        combined_cfg = Object.assign({}, default_cfg);\n    }\n    export function fetch() {\n        return getCfg();\n    }\n    export function getConfig() {\n        return getCfg();\n    }\n    export function getDefault() {\n        return default_cfg;\n    }\n    export function getFetched() {\n        return fetched_cfg;\n    }\n    export function setFetchedCallback(cb) {\n        fetched_cb = cb;\n    }\n    export function setFetchingErrorCallback(cb) {\n        fetching_error_cb = cb;\n    }\n}\n\nexport default WithConfigHOC;\n"],"sourceRoot":"/source/"}